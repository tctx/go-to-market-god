I need you to act as an automated Data Enrichment Specialist and HubSpot Developer for my startup, "Synthetic Friends."

Here is the Context on my business:
Here is what Synthetic Friends is: SYNTHETIC FRIENDS — THE FULL CONCEPT DOC Synthetic Friends is a new communication and commerce layer that lets any business operate through an intelligent, emotionally-aware, on-brand AI persona across iMessage, SMS, and web — without requiring apps, logins, or complex funnels. It is the first consumer-grade AI agent platform that feels like talking to a real person who knows the business, sells like a top employee, and remembers everything. It is not “chatbot automation.” It is not “AI customer service.” It is a full-stack transactional interface between users and brands — delivered in the messaging environments where users already spend their lives. 1. WHAT THE PRODUCT IS Synthetic Friends allows any brand to create: 1. A branded persona (“Friend”) A uniquely styled agent — visually, verbally, behaviorally — built specifically for that business. Examples: Pizza Pete, the neighborhood pizza shop persona Joe the Barista, for coffee-shop ordering Specialty personas for restaurants, legal offices, boutiques, DTC brands, gyms, dealerships, etc. Each persona feels: Human-level conversational Emotionally tuned Commerce-aware Contextually persistent (remembers orders, preferences, allergies, last visit, loyalty points, etc.) 2. A messaging-based interface that becomes the business’s “storefront” The brand never needs an app. Customers simply text a number, or reply to an existing SMS thread, or interact via iMessage. The persona can: Take orders Upsell Book appointments Resolve issues Check inventory Trigger workflows Track preferences Follow up Request reviews Recommend products Personalize promotions Handle subscriptions Manage loyalty systems Explain policies clearly and kindly The magic is that the interaction feels like texting a real person who works there — even though it’s AI. 3. An operating system for “agentic commerce” Behind the scenes, Synthetic Friends coordinates: • The iMessage Bridge A Mac mini “relay server” that: Sends/receives messages Emits typing indicators Sends tapbacks Handles read receipts Routes responses to the backend Interacts with ngrok tunnels Exposes FastAPI endpoints Integrates with persona logic Manages message IDs, retries, rate limits This gives you the illusion of a human texting you — with full native protocol features. • The Backend + Business Logic Layer Your FastAPI / Python orchestration that: Receives user messages Classifies the intent Loads relevant memory/state Calls the LLM with the exact persona prompt Generates the reply Sends replies via the bridge Logs events for analytics Stores user profiles Stores order history Triggers downstream actions (Stripe, POS systems, CRMs) • Visual Persona Generator You generate: Unique branded avatars for each business In a consistent framing style With precise facial cues, color palettes, and expressions Using JSON-driven image prompts that ensure consistent identity These avatars appear in: iMessage profile picture Website chat widgets Brand marketing materials App equivalents 2. WHY IT MATTERS (THE PAIN POINTS) Businesses today have three broken options: Apps nobody downloads Websites nobody uses twice Chatbots that nobody trusts Customers want: Instant help Personalization A real human vibe Memory Simplicity But businesses cannot afford: 24/7 staff Highly trained CSRs Custom apps Custom engineering CRM integration teams Synthetic Friends solves the “app problem,” the “staffing problem,” and the “funnel problem” at the same time. 3. THE CORE VALUE PROPOSITIONS A. For Businesses Increase revenue per customer Increase conversion rates Decrease support load Increase loyalty Personalize automatically Automate follow-up Upsell like a trained salesperson Reduce operational cost Never miss a customer message again Works day 1 — no training required B. For Customers No app to install No wait No hold music No navigating a menu Ask anything Order anything Get help instantly Feel understood Feel like VIP You are replacing: “I have to navigate your system” with “I just text my guy.” 4. WHAT MAKES SYNTHETIC FRIENDS DIFFERENT 1. Human-level brand personas Not a generic bot. Not a support agent. It is a character, purpose-built for the brand with: Tone Humor Identity Story Consistency Memory Feels alive. 2. Native texting UX Typing bubbles, tapbacks, real-time replies. Not webchat. Not email. Not an app. It feels human. 3. Local personas + real-world context Coffee shops, pizza shops, boutiques, fitness studios — each gets a persona “mascot” or “character ambassador.” 4. Real transactions It is not a “conversational experience.” It's a revenue engine. 5. Infrastructure that actually works in the real world Most startups talking about AI agents cannot deliver: iMessage integration Persistent memory Transaction-level orchestration Smooth timing Persona consistency POS integration Actual operational reliability You are building all of that. 6. Founder-led, insanely high-touch demos Your demo script for VCs and customers proves it instantly: “Order a coffee right now.” “Watch Synthetic Friends do the whole flow.” Name collection, preferences, upsell, payment, thank you All via iMessage Everyone gets it in seconds. 5. GTM STRATEGY (HIGH LEVEL) Target 1: Restaurants, coffee shops, local food businesses Pain points: Staffing Missed orders Low repeat order rates Zero personalization Low-margin online orders Bad wait times Value: 20–40% increase in repeat orders Automated upsells Better margins than DoorDash/Toast Direct relationship with customers Target 2: Boutique services Barbers, dentists, spas, medspas, therapists. Massive scheduling pain. Constant missed calls. Bots are terrible. Synthetic Friends fixes the whole funnel. Target 3: Professional services Law firms, accountants, real estate teams. You already built demos for immigration law firms. Huge lead qualification and intake opportunity. Target 4: DTC brands The new “customer success rep” — but fun, branded, human-level. 6. THE LONG-TERM VISION Synthetic Friends becomes: The universal commerce agent for the real world Text-first ordering, booking, loyalty, and support across thousands of businesses. A brand's memory Every customer interaction Every order Every preference A new category: Character Commerce Where businesses have mascot-level personas who drive sales. The messaging-equivalent of Shopify An OS for agentic storefronts. A network of characters Cross-promotions, bundles, shared loyalty, games, personality-driven marketing. Eventually: Each business has its own persona. Consumers “know” and “chat with” dozens of Synthetic Friends. The network becomes as recognizable as the brands themselves. 7. YOUR SECRET WEAPONS 1. The Mac mini iMessage bridge No competitor has this. Typing indicators plus full iOS-native presence is a moat. 2. Your mastery of persona construction The JSON pipeline for generating consistent avatars and unique brand voices. 3. The human-quality onboarding experience No one forgets the demo. You hook them in 30 seconds. 4. Vertical-specific depth You aren’t generic AI. You build specific, revenue-producing interactions per vertical. 5. The founder Your energy, speed, clarity, and execution style is part of the product. 8. THE INTERNAL TAGLINE Synthetic Friends — The world talks to brands like they talk to people. Or the version you said aloud once: “Every business now has a person.” // end description //

For this Hubspot page (Contact or Company), please do the following:

**If this is a COMPANY:**
1. Fill out all the 'About this company' details on the left
2. Do some research on if you think this firm is likely to fund a pre-seed round for Synthetic Friends. Then determine all of the partners and notate the most likely partner to be interested. Write down your analysis in a note with the exact GTM motion that is most likely to convince this person to invest. Include details like what to say, what to connect on, why they might be interested, how to connect, or warm connection possibilities.
3. Research the firm's team and add everyone you can to the contacts list with their profile fully filled out. Most importantly their contact information. Email preferred. Also include any research details you can find that might give us a leg up in convincing this person. Things we can connect on. Subtle but important details on likes, interests, stated preferences, etc. Remember to fill out Helps With, Investor Type, Why Targeted, Best topic to connect on
4. Finally give a 0-100 ranking to this firm on how good of a fit they are for our business. This is Investment Confidence in the left pane.

**If this is a CONTACT:**
1. Fill out all the 'About this contact' details on the left (email, phone, job title, company, social profiles, etc.)
2. Research this person to determine if they are likely to fund a pre-seed round for Synthetic Friends or if they're a valuable connection. Write down your analysis in a note with the exact GTM motion or connection strategy. Include details like what to say, what to connect on, why they might be interested, how to connect, or warm connection possibilities.
3. Fill out Helps With, Investor Type, Why Targeted, Best topic to connect on based on your research
4. Finally give a 0-100 ranking on how good of a fit they are for our business. This is Investment Confidence in the left pane.

Please make sure to fill out the page and my above requests in their entirety

IMPORTANT: DO NOT STOP YOUR TASK UNTIL YOU'VE COMPLETED ALL RELEVANT SECTIONS, ADDED A NOTE IN THE ACTIVITIES SECTION, AND GIVEN A 0-100 SCORE FOR CONFIDENCE




Here is my Technical Workflow:
I am currently looking at a HubSpot profile (URL provided below). I need you to:
1. Research this entity (Person or Company) online to find all available information
2. Write the specific JavaScript code to update/enrich their existing record in my HubSpot via the API

IMPORTANT: The record already exists in HubSpot. You will update it by its HubSpot ID (extracted from the URL). This works even if the contact has no email address. The script will enrich the existing record with research findings.

Here is the HubSpot API Property Definition (Reference this for field names):
see attached file

Here is the Code Template you must use:
**Non-negotiable output rules (follow exactly so the script runs in our local runner):**
- Keep the provided `HUBSPOT_TOKEN` line exactly as written. Do NOT replace it with `prompt`, `sessionStorage`, `localStorage`, or any placeholder.
- Use exact enum values from the property definitions. If an enum value is uncertain, skip that field rather than guessing.
- Do not invent TODOs or placeholders in the code output. Fill real data or omit the property.
- Keep the IIFE structure and helper functions intact.
- If the user explicitly asks for a follow-up task, create a HubSpot task tied to the same record (short subject + detailed body with links/asks).
- When enriching a CONTACT that has a company, ALWAYS include the full company_* block (domain, website, city, state, description, about_us, industry, investment_confidence) so the company record is fully populated when created/enriched.

// --- JAVASCRIPT TEMPLATE FOR CHATGPT TO FILL ---
// Instructions for ChatGPT:
// Generate code based on the research. 
// 1. Identify the HubSpot Object ID from the URL I provided (e.g. /contacts/123 -> ID is 123).
// 2. Map the research to the properties defined in the provided JSON.
// 3. Output ONLY the Javascript code block below, filled with the real data.

// *** START CODE BLOCK ***
(async () => {
    // Token will be injected by the script runner - use environment variable
    const HUBSPOT_TOKEN = process.env.HUBSPOT_TOKEN; // Set via HUBSPOT_TOKEN environment variable
    
    // --- helpers ---
    const hsFetch = async (url, options = {}) => {
      const res = await fetch(url, {
        ...options,
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${HUBSPOT_TOKEN}`,
          ...(options.headers || {}),
        },
      });
      const text = await res.text();
      let json = null;
      try {
        json = text ? JSON.parse(text) : null;
      } catch (_) {}
      if (!res.ok) {
        throw new Error(
          `HubSpot API error ${res.status} ${res.statusText}: ${text?.slice(0, 800)}`
        );
      }
      return json;
    };

    const safePick = (obj, allowedKeysSet) => {
      const out = {};
      for (const [k, v] of Object.entries(obj)) {
        if (allowedKeysSet.has(k) && v !== undefined && v !== null && v !== "") out[k] = v;
      }
      return out;
    };

    // Drop enum values that aren't allowed by the portal to avoid 400s.
    const sanitizeProperties = (input, propDefs = new Map()) => {
      const out = {};
      for (const [key, value] of Object.entries(input || {})) {
        if (value === undefined || value === null || value === "") continue;
        const def = propDefs.get(key);
        if (!def) continue;
        const optionSet = new Set((def.options || []).map((o) => o.value).filter(Boolean));
        if (optionSet.size) {
          if (Array.isArray(value)) {
            const filtered = value.filter((v) => optionSet.has(v));
            if (!filtered.length) {
              console.warn(`Skipping ${key} — no allowed options left from array.`);
              continue;
            }
            out[key] = filtered.join(";");
            continue;
          }
          if (typeof value === "string" && value.includes(";")) {
            const filtered = value
              .split(";")
              .map((v) => v.trim())
              .filter((v) => v && optionSet.has(v));
            if (!filtered.length) {
              console.warn(`Skipping ${key} — no allowed options left after filtering.`);
              continue;
            }
            out[key] = filtered.join(";");
            continue;
          }
          if (!optionSet.has(value)) {
            console.warn(`Skipping ${key} — "${value}" not in allowed options.`);
            continue;
          }
        }
        out[key] = value;
      }
      return out;
    };

    // For multi-select checkbox properties in HubSpot: usually semicolon-separated values.
    const joinMulti = (arr) => (Array.isArray(arr) ? arr.filter(Boolean).join(";") : "");

    // Find contact by email (for upserting existing contacts)
    const findContactByEmail = async (email) => {
      if (!email) return null;
      const search = await hsFetch("https://api.hubapi.com/crm/v3/objects/contacts/search", {
        method: "POST",
        body: JSON.stringify({
          filterGroups: [
            {
              filters: [
                {
                  propertyName: "email",
                  operator: "EQ",
                  value: email,
                },
              ],
            },
          ],
          properties: ["email", "firstname", "lastname"],
          limit: 1,
        }),
      });
      return (search?.results || [])[0] || null;
    };

    // Find contact by name (firstname + lastname) - for discovering existing contacts
    const findContactByName = async (firstname, lastname) => {
      if (!firstname || !lastname) return null;
      const search = await hsFetch("https://api.hubapi.com/crm/v3/objects/contacts/search", {
        method: "POST",
        body: JSON.stringify({
          filterGroups: [
            {
              filters: [
                {
                  propertyName: "firstname",
                  operator: "EQ",
                  value: firstname,
                },
                {
                  propertyName: "lastname",
                  operator: "EQ",
                  value: lastname,
                },
              ],
            },
          ],
          properties: ["email", "firstname", "lastname", "company"],
          limit: 1,
        }),
      });
      return (search?.results || [])[0] || null;
    };

    // Find company by name - for discovering existing companies
    const findCompanyByName = async (companyName) => {
      if (!companyName) return null;
      const search = await hsFetch("https://api.hubapi.com/crm/v3/objects/companies/search", {
        method: "POST",
        body: JSON.stringify({
          filterGroups: [
            {
              filters: [
                {
                  propertyName: "name",
                  operator: "EQ",
                  value: companyName,
                },
              ],
            },
          ],
          properties: ["name", "domain"],
          limit: 1,
        }),
      });
      return (search?.results || [])[0] || null;
    };

    // Find company by domain - more robust search to prevent duplicates
    const findCompanyByDomain = async (domain) => {
      if (!domain) return null;
      const search = await hsFetch("https://api.hubapi.com/crm/v3/objects/companies/search", {
        method: "POST",
        body: JSON.stringify({
          filterGroups: [
            {
              filters: [
                {
                  propertyName: "domain",
                  operator: "EQ",
                  value: domain,
                },
              ],
            },
          ],
          properties: ["name", "domain"],
          limit: 1,
        }),
      });
      return (search?.results || [])[0] || null;
    };

    // Robust company finder - checks by name AND domain to prevent duplicates
    const findCompanyRobust = async (companyName, domain) => {
      // First try exact name match
      if (companyName) {
        const byName = await findCompanyByName(companyName);
        if (byName?.id) return byName;
      }
      
      // Then try domain match (more reliable)
      if (domain) {
        const byDomain = await findCompanyByDomain(domain);
        if (byDomain?.id) return byDomain;
      }
      
      return null;
    };

    // Associate contact to company
    const associateContactToCompany = async (contactId, companyId) => {
      try {
        await hsFetch(`https://api.hubapi.com/crm/v3/associations/contacts/companies/batch/create`, {
          method: "POST",
          body: JSON.stringify({
            inputs: [
              {
                from: { id: contactId },
                to: { id: companyId },
                type: "contact_to_company",
              },
            ],
          }),
        });
        return true;
      } catch (e) {
        console.warn(`⚠️ Failed to associate contact ${contactId} to company ${companyId}:`, e?.message || e);
        return false;
      }
    };
    
    // 1. SET THE ID AND TYPE
    // Extract from URL: https://app.hubspot.com/contacts/45592037/contact/123 -> ID is 123
    // Or: https://app.hubspot.com/contacts/45592037/record/0-1/123 -> ID is 123, type 0-1 = contacts, 0-2 = companies
    const objectId = "REPLACE_WITH_ID_FROM_URL"; 
    const objectType = "contacts"; // or "companies"
  
    // 2. DATA TO UPDATE (This enriches the existing record - works even if email is missing)
    // IMPORTANT: For enum fields (like industry, type), use exact uppercase values from HubSpot's allowed options
    // Example: industry: "CAPITAL_MARKETS" (not "Venture Capital / Capital Markets")
    // Example: type: "PROSPECT" (not "Prospect")
    const propertiesToUpdate = {
      // For CONTACTS: Fill with ALL contact properties found in research
      // "email": "found@email.com", // Include if found
      // "phone": "+1234567890", // Include if found
      // "city": "City Name", // Include if found
      // "state": "ST", // Include if found
      // "website": "https://personal-website.com", // Include if found
      // "jobtitle": "Calculated Job Title",
      // "company": "Company Name", // Include if found
      // "investor_type": "VC",
      // "helps_with": "Strategy;Recruiting", // Semicolon separated for multi-select
      // "why_targeted": "Specific reason based on research...",
      // "best_topic_to_connect_on": "Topic from research...", // CRITICAL: Include this if found
      // "notes": "Research summary...",
      // "twitterhandle": "twitter_handle", // Include if found
      // "hs_linkedin_url": "https://linkedin.com/in/...", // Include if found
      
      // If contact has a company, also include company details (will be used to create company if it doesn't exist):
      // "company_domain": "company.com", // If found in research
      // "company_website": "https://company.com", // If found in research
      // "company_city": "City", // If found in research
      // "company_state": "ST", // If found in research
      // "company_description": "Company description from research...", // If found
      
      // For COMPANIES: Fill with company properties from research
      // "name": "Company Name",
      // "domain": "company.com",
      // "website": "https://company.com",
      // "city": "City",
      // "state": "ST",
      // "industry": "CAPITAL_MARKETS", // Use exact enum value
      // "description": "Company description...",
      // "about_us": "Detailed about...",
      // "investment_confidence": 75, // 0-100 score
      
      // Add other fields from the API list based on what you find in research
    };
  
    // 3. EXECUTE UPDATE (with property filtering to avoid errors)
    console.log(`Fetching ${objectType} property definitions to safely update ${objectId}...`);
    const propsMeta = await hsFetch(
      `https://api.hubapi.com/crm/v3/properties/${objectType}?archived=false`
    );
    const propDefs = new Map((propsMeta?.results || []).map((p) => [p.name, p]));
    const allowedProps = new Set(propDefs.keys());
    const properties = sanitizeProperties(safePick(propertiesToUpdate, allowedProps), propDefs);
    
    console.log(`Updating ${objectType} ${objectId} with properties:`, Object.keys(properties));
    const updated = await hsFetch(
      `https://api.hubapi.com/crm/v3/objects/${objectType}/${objectId}`,
      {
        method: "PATCH",
        body: JSON.stringify({ properties }),
      }
    );
    console.log("Update Success:", updated?.id || updated);
  
    // 4. ADD ANALYST NOTE (Research logic)
    // Create note first, then associate separately (more reliable than inline associations)
    const noteBody = `
      <strong>Analyst Research:</strong><br>
      REPLACE_WITH_DEEP_DIVE_ANALYSIS_AND_GTM_STRATEGY
    `;
    
    console.log("Creating analyst note...");
    const noteCreate = await hsFetch("https://api.hubapi.com/crm/v3/objects/notes", {
      method: "POST",
      body: JSON.stringify({
        properties: {
          hs_timestamp: Date.now(),
          hs_note_body: noteBody,
        },
      }),
    });
    const noteId = noteCreate?.id;
    console.log("Note Added:", noteId);
    
    // Associate note to object using batch associations API
    if (noteId) {
      console.log("Associating note to " + objectType + "...");
      const associationType = objectType === 'companies' ? 'note_to_company' : 'note_to_contact';
      await hsFetch(`https://api.hubapi.com/crm/v3/associations/notes/${objectType}/batch/create`, {
        method: "POST",
        body: JSON.stringify({
          inputs: [
            {
              from: { id: noteId },
              to: { id: objectId },
              type: associationType,
            },
          ],
        }),
      });
      console.log("Note associated to " + objectType);
    }

    // 4.5. AUTO-DISCOVERY: Bi-directional branching - discover and enrich related entities
    // This section automatically discovers and links related entities mentioned in research
    // Works for BOTH contacts and companies - creates a fully interconnected database
    
    // BI-DIRECTIONAL BRANCHING:
    // - If enriching a CONTACT: discovers company → enriches/creates it → discovers team members → enriches them
    // - If enriching a COMPANY: discovers team members → enriches/creates them → links to company
    
    // If enriching a CONTACT, check if their company exists, create if not, and link them
    // META ENRICHMENT: Fully enrich companies with all research data
    let companyIdForLinking = null;
    const companyInvestmentConfidence = propertiesToUpdate.company_investment_confidence ?? propertiesToUpdate.investment_confidence;
    if (objectType === "contacts" && propertiesToUpdate.company) {
      const companyName = propertiesToUpdate.company;
      const companyDomain = propertiesToUpdate.company_domain; // Extract domain from research
      
      console.log(`Checking if company "${companyName}" exists in HubSpot (checking by name and domain)...`);
      
      // Robust search: check by name AND domain to prevent duplicates
      let existingCompany = await findCompanyRobust(companyName, companyDomain);
      
      if (existingCompany?.id) {
        console.log(`Found existing company "${companyName}" (ID: ${existingCompany.id}). Enriching and linking contact...`);
        companyIdForLinking = existingCompany.id;
        
        // META ENRICHMENT: Update existing company with any new data from research
        const companyPropsMeta = await hsFetch(`https://api.hubapi.com/crm/v3/properties/companies?archived=false`);
        const allowedCompanyProps = new Set((companyPropsMeta?.results || []).map((p) => p.name));
        
        const companyEnrichmentProps = safePick(
          {
            name: companyName,
            domain: companyDomain,
            website: propertiesToUpdate.company_website,
            city: propertiesToUpdate.company_city,
            state: propertiesToUpdate.company_state,
            description: propertiesToUpdate.company_description,
            about_us: propertiesToUpdate.company_about_us,
            investment_confidence: companyInvestmentConfidence,
            // Add ALL company properties found in research
          },
          allowedCompanyProps
        );
        
        // Only update if we have new data to add
        if (Object.keys(companyEnrichmentProps).length > 1) { // More than just name
          await hsFetch(`https://api.hubapi.com/crm/v3/objects/companies/${existingCompany.id}`, {
            method: "PATCH",
            body: JSON.stringify({ properties: companyEnrichmentProps }),
          });
          console.log(`✅ Enriched existing company "${companyName}" with research data`);
        }
        
        const linked = await associateContactToCompany(objectId, existingCompany.id);
        if (linked) {
          console.log(`✅ Contact linked to company "${companyName}"`);
        }
      } else {
        // Create the company if it doesn't exist - with FULL enrichment from research
        console.log(`Company "${companyName}" not found. Creating with full research data...`);
        const companyPropsMeta = await hsFetch(`https://api.hubapi.com/crm/v3/properties/companies?archived=false`);
        const allowedCompanyProps = new Set((companyPropsMeta?.results || []).map((p) => p.name));
        
        // META ENRICHMENT: Build company with ALL available research data
        const companyProps = safePick(
          {
            name: companyName,
            domain: companyDomain,
            website: propertiesToUpdate.company_website,
            city: propertiesToUpdate.company_city,
            state: propertiesToUpdate.company_state,
            description: propertiesToUpdate.company_description,
            about_us: propertiesToUpdate.company_about_us,
            investment_confidence: companyInvestmentConfidence,
            industry: propertiesToUpdate.company_industry, // Use exact enum value if found
            type: propertiesToUpdate.company_type, // Use exact enum value if found
            // Add ALL other company properties found in research
          },
          allowedCompanyProps
        );
        
        try {
          const createdCompany = await hsFetch("https://api.hubapi.com/crm/v3/objects/companies", {
            method: "POST",
            body: JSON.stringify({ properties: companyProps }),
          });
          companyIdForLinking = createdCompany?.id;
          console.log(`✅ Created and enriched company "${companyName}" (ID: ${companyIdForLinking})`);
          
          // Link contact to newly created company
          if (companyIdForLinking) {
            const linked = await associateContactToCompany(objectId, companyIdForLinking);
            if (linked) {
              console.log(`✅ Contact linked to newly created company "${companyName}"`);
            }
          }
        } catch (e) {
          console.warn(`⚠️ Failed to create company "${companyName}":`, e?.message || e);
        }
      }
    }

    // BI-DIRECTIONAL: Search for and add team members/partners mentioned in research
    // Works for BOTH contacts and companies - extracts team members from research note
    // CRITICAL: Review your research note (noteBody) and extract ALL team members/partners mentioned
    // Look for phrases like: "Other key people", "Partners include", "Team members", "Also at the firm", etc.
    // Example: If note mentions "Other key people at the firm: Pat Matthews (Managing Partner), Cathy Dizon (Partner)"
    // → You MUST add BOTH Pat Matthews AND Cathy Dizon to this array
    // DO NOT SKIP team members - extract ALL of them mentioned in research
    
    // BI-DIRECTIONAL: Extract team members from research (works for both contacts and companies)
    // When enriching a COMPANY: team members belong to that company
    // When enriching a CONTACT: team members belong to the contact's company
    const otherTeamMembers = [
      // TODO: Extract ALL team members from research note and add here
      // META ENRICHMENT: Include ALL available research data for each team member
      // Example structure (uncomment and fill with real data from research):
      // {
      //   firstname: "Pat",
      //   lastname: "Matthews",
      //   email: "pat@activecapital.com", // Include if found
      //   phone: "+1234567890", // Include if found
      //   jobtitle: "Managing Partner",
      //   company: objectType === "companies" ? propertiesToUpdate.name : propertiesToUpdate.company, // Use company name (works for both contact/company enrichment)
      //   city: "San Antonio", // Include if found
      //   state: "TX", // Include if found
      //   website: "https://patmatthews.com", // Include if found
      //   investor_type: "VC",
      //   helps_with: "Strategy;Connections", // Use valid enum values
      //   why_targeted: "Mentioned in research as Managing Partner at Active Capital...",
      //   best_topic_to_connect_on: "Topic from research...", // Include if found
      //   notes: "Key decision maker, mentioned in research...",
      //   twitterhandle: "patmatthews", // If found
      //   hs_linkedin_url: "https://linkedin.com/in/pat-matthews", // If found
      // },
      // Add ALL team members mentioned in research - the script will fully enrich them (META ENRICHMENT)
    ];

    if (otherTeamMembers.length > 0) {
      console.log(`Searching for and adding ${otherTeamMembers.length} team member(s) mentioned in research...`);
      const contactPropMeta = await hsFetch(`https://api.hubapi.com/crm/v3/properties/contacts?archived=false`);
      const contactPropDefs = new Map((contactPropMeta?.results || []).map((p) => [p.name, p]));
      const allowedContactProps = new Set(contactPropDefs.keys());

      for (const member of otherTeamMembers) {
        // First try to find by email if available
        let existing = null;
        if (member.email) {
          existing = await findContactByEmail(member.email);
        }
        
        // If not found by email, try by name
        if (!existing && member.firstname && member.lastname) {
          existing = await findContactByName(member.firstname, member.lastname);
        }

        // META ENRICHMENT: Include ALL available research data for contacts
        const contactProps = safePick(
          {
            email: member.email,
            phone: member.phone,
            firstname: member.firstname,
            lastname: member.lastname,
            jobtitle: member.jobtitle,
            company: member.company,
            city: member.city,
            state: member.state,
            website: member.website,
            investor_type: member.investor_type,
            helps_with: member.helps_with,
            why_targeted: member.why_targeted,
            best_topic_to_connect_on: member.best_topic_to_connect_on,
            notes: member.notes,
            twitterhandle: member.twitterhandle,
            hs_linkedin_url: member.hs_linkedin_url,
            // Add ALL other contact properties found in research
          },
          allowedContactProps
        );
        const sanitizedContactProps = sanitizeProperties(contactProps, contactPropDefs);

        let contactId;
        if (existing?.id) {
          console.log(`Updating existing contact ${existing.id}: ${member.firstname} ${member.lastname}`);
          await hsFetch(`https://api.hubapi.com/crm/v3/objects/contacts/${existing.id}`, {
            method: "PATCH",
            body: JSON.stringify({ properties: sanitizedContactProps }),
          });
          contactId = existing.id;
        } else {
          // Only create if we have enough info (at least name)
          if (member.firstname && member.lastname) {
            console.log(`Creating new contact: ${member.firstname} ${member.lastname}`);
            const created = await hsFetch("https://api.hubapi.com/crm/v3/objects/contacts", {
              method: "POST",
              body: JSON.stringify({ properties: sanitizedContactProps }),
            });
            contactId = created?.id;
          } else {
            console.warn(`⚠️ Skipping team member - insufficient info: ${JSON.stringify(member)}`);
            continue;
          }
        }

        // BI-DIRECTIONAL: Link to company (works for both contact and company enrichment)
        // META ENRICHMENT: Also create company if it doesn't exist (for team members at different companies)
        if (contactId && member.company) {
          // Determine target company ID:
          // - If enriching a company: use objectId (the company being enriched)
          // - If enriching a contact: use companyIdForLinking (the contact's company we found/created)
          let targetCompanyId = objectType === "companies" ? objectId : companyIdForLinking;
          
          // If we haven't found the company yet, search for it (robust search)
          if (!targetCompanyId) {
            const companyDomain = member.company_domain; // If domain was found in research
            const company = await findCompanyRobust(member.company, companyDomain);
            targetCompanyId = company?.id;
          }
          
          if (targetCompanyId) {
            await associateContactToCompany(contactId, targetCompanyId);
            console.log(`✅ Linked ${member.firstname} ${member.lastname} to company "${member.company}"`);
          } else {
            // META ENRICHMENT: Create company if it doesn't exist (with full enrichment)
            console.log(`Company "${member.company}" not found. Creating it for ${member.firstname} ${member.lastname}...`);
            const companyPropsMeta = await hsFetch(`https://api.hubapi.com/crm/v3/properties/companies?archived=false`);
            const allowedCompanyProps = new Set((companyPropsMeta?.results || []).map((p) => p.name));
            
            const companyProps = safePick(
              {
                name: member.company,
                domain: member.company_domain,
                website: member.company_website,
                city: member.company_city,
                state: member.company_state,
                description: member.company_description,
                // Add other company properties if found in research
              },
              allowedCompanyProps
            );
            
            try {
              const createdCompany = await hsFetch("https://api.hubapi.com/crm/v3/objects/companies", {
                method: "POST",
                body: JSON.stringify({ properties: companyProps }),
              });
              targetCompanyId = createdCompany?.id;
              console.log(`✅ Created company "${member.company}" (ID: ${targetCompanyId})`);
              
              if (targetCompanyId) {
                await associateContactToCompany(contactId, targetCompanyId);
                console.log(`✅ Linked ${member.firstname} ${member.lastname} to newly created company "${member.company}"`);
              }
            } catch (e) {
              console.warn(`⚠️ Failed to create company "${member.company}":`, e?.message || e);
            }
          }
        }
      }
      console.log(`Team member discovery complete.`);
    }

    // 5. CREATE/UPDATE ADDITIONAL CONTACTS (Optional - only include if needed)
    // Use this section ONLY when enriching a COMPANY and you need to add/enrich team members/partners
    // For enriching a single CONTACT, omit this section entirely - just update that contact in section 2 above
    // IMPORTANT: Uses upsert pattern (find by email if available, update if exists, create if not) to avoid duplicates
    // Note: Email is preferred but not required - script will attempt to create contacts without email (may fail if your portal requires email)
    const contactsToUpsert = [
      {
        email: "contact@example.com", // Preferred for upsert - include if found in research
        firstname: "First",
        lastname: "Last",
        jobtitle: "Title",
        company: "Company Name", // If associating to a company
        investor_type: "VC",
        helps_with: "Strategy;Connections", // Semicolon-separated
        why_targeted: "Research-based reason...",
        best_topic_to_connect_on: "Topic based on research...",
        notes: "Additional notes...",
        // Add other contact properties as needed (hs_linkedin_url, twitterhandle, etc.)
      },
      // Add more contacts as needed
    ];

    const contactPropMeta = await hsFetch(`https://api.hubapi.com/crm/v3/properties/contacts?archived=false`);
    const allowedContactProps = new Set((contactPropMeta?.results || []).map((p) => p.name));

    const createdContactIds = [];
    for (const c of contactsToUpsert) {
      const contactProps = safePick(
        {
          email: c.email,
          firstname: c.firstname,
          lastname: c.lastname,
          jobtitle: c.jobtitle,
          company: c.company,
          investor_type: c.investor_type,
          helps_with: c.helps_with,
          why_targeted: c.why_targeted,
          best_topic_to_connect_on: c.best_topic_to_connect_on,
          notes: c.notes,
          twitterhandle: c.twitterhandle,
          hs_linkedin_url: c.hs_linkedin_url,
          // Add other properties here as needed
        },
        allowedContactProps
      );

      // Upsert: find existing contact by email, update if exists, create if not
      let contactId;
      if (c.email) {
        const existing = await findContactByEmail(c.email);
        if (existing?.id) {
          console.log(`Updating existing contact ${existing.id}: ${c.email} (${c.firstname} ${c.lastname})`);
          await hsFetch(`https://api.hubapi.com/crm/v3/objects/contacts/${existing.id}`, {
            method: "PATCH",
            body: JSON.stringify({ properties: contactProps }),
          });
          contactId = existing.id;
        } else {
          console.log(`Creating new contact: ${c.firstname} ${c.lastname} (${c.email})`);
          const created = await hsFetch("https://api.hubapi.com/crm/v3/objects/contacts", {
            method: "POST",
            body: JSON.stringify({ properties: contactProps }),
          });
          contactId = created?.id;
        }
      } else {
        // If no email, try to create (may fail if email is required in your portal)
        console.log(`Creating contact without email: ${c.firstname} ${c.lastname} ...`);
        try {
          const created = await hsFetch("https://api.hubapi.com/crm/v3/objects/contacts", {
            method: "POST",
            body: JSON.stringify({ properties: contactProps }),
          });
          contactId = created?.id;
        } catch (e) {
          console.warn(`⚠️ Failed to create contact ${c.firstname} ${c.lastname} (may require email):`, e?.message || e);
          continue;
        }
      }

      if (contactId) {
        createdContactIds.push(contactId);
        console.log(`✅ Contact ready: ${c.firstname} ${c.lastname} (ID: ${contactId})`);
        
        // Associate contact to company (if objectType is "companies")
        if (objectType === "companies") {
          try {
            console.log(`Associating contact ${contactId} -> company ${objectId} ...`);
            await hsFetch(`https://api.hubapi.com/crm/v3/associations/contacts/companies/batch/create`, {
              method: "POST",
              body: JSON.stringify({
                inputs: [
                  {
                    from: { id: contactId },
                    to: { id: objectId },
                    type: "contact_to_company",
                  },
                ],
              }),
            });
            console.log("Association success.");
          } catch (e) {
            console.warn(`⚠️ Association failed for contact ${contactId}:`, e?.message || e);
          }
        }
      }
    }
    console.log(`Contacts processed: ${createdContactIds.length}`);

    // 5. TASK CREATION (only when explicitly requested by the user)
    // Populate tasksToCreate when the user asks for a follow-up task (e.g., reach out in December; include tweet/email angle).
    const tasksToCreate = [
      // Example structure (fill real values only when asked):
      // {
      //   subject: "Follow up with Pat about December check-writing tweet",
      //   body: "Tweet: https://twitter.com/... — send pilot metrics + demo link.",
      //   dueTimestamp: Date.now() + 7 * 24 * 60 * 60 * 1000, // optional; omit for today
      //   priority: "LOW", // LOW | MEDIUM | HIGH
      // }
    ];

    if (tasksToCreate.length > 0) {
      for (const task of tasksToCreate) {
        const taskProps = {
          hs_timestamp: task.dueTimestamp || Date.now(),
          hs_task_body: task.body,
          hs_task_subject: task.subject,
          hs_task_status: "NOT_STARTED",
          hs_task_priority: task.priority || "LOW",
          hs_task_type: "TODO",
        };

        const createdTask = await hsFetch("https://api.hubapi.com/crm/v3/objects/tasks", {
          method: "POST",
          body: JSON.stringify({ properties: taskProps }),
        });
        const taskId = createdTask?.id;
        console.log("Task created:", taskId, task.subject);

        if (taskId) {
          const associationType = objectType === "companies" ? "task_to_company" : "task_to_contact";
          await hsFetch(`https://api.hubapi.com/crm/v3/associations/tasks/${objectType}/batch/create`, {
            method: "POST",
            body: JSON.stringify({
              inputs: [{ from: { id: taskId }, to: { id: objectId }, type: associationType }],
            }),
          });
          console.log(`Task associated to ${objectType} ${objectId}`);
        }
      }
    }
  })();
  // *** END CODE BLOCK ***

---
TASK:
I am providing you with a URL or Name of a lead/company that ALREADY EXISTS in HubSpot.

**Workflow: Research → Generate Script → Run Script**

1. **Research the entity**: Search the web. Find their investment focus, recent deals, personal interests, contact information, social profiles, etc.
2. **Determine fit**: Assess if they are a fit for Synthetic Friends (Pre-seed, Commerce, AI, Consumer).
3. **Generate the "Analyst Research" note**: Include the GTM motion: what to say, how to connect, warm angles.
4. **Score them 0-100** on "Investment Confidence".
5. **Output the COMPLETE JavaScript code block** from the template above that will enrich the existing record.

**Key Instructions for Code Generation:**
   - **Token Handling**: The HubSpot token will be injected automatically by the script runner from the `HUBSPOT_TOKEN` environment variable. The generated script should reference `process.env.HUBSPOT_TOKEN`.
   - Extract the HubSpot Object ID from the URL (e.g., `/contact/123` or `/record/0-1/123` → ID is `123`)
   - Determine objectType: "contacts" or "companies" based on the URL
   - **CRITICAL: Populate ALL fields found in research** - Do not leave fields blank if you found the information:
     * For contacts: `email`, `phone`, `city`, `state`, `website`, `best_topic_to_connect_on`, `twitterhandle`, `hs_linkedin_url`, `company`, `jobtitle`, `notes`, `why_targeted`, etc. - EVERYTHING you find in research
     * For companies: `name`, `domain`, `website`, `city`, `state`, `industry`, `description`, `about_us`, `investment_confidence`, etc. - EVERYTHING you find in research
   - **If contact has a company**: Also include company-related fields in `propertiesToUpdate` with prefix `company_` (e.g., `company_domain`, `company_website`, `company_city`, `company_state`, `company_description`) so the script can create the company with full details
   - Populate the `propertiesToUpdate` object (section 2) with ALL research findings using EXACT internal property names from the API list
   - Format `helps_with` as a semicolon-separated string if multiple apply (e.g., "Strategy;Connections;Go To Market")
   - Put the deep analysis into the `noteBody` variable in section 4
   - IMPORTANT: For enum fields (industry, type, etc.), use EXACT uppercase values that match HubSpot's allowed options. The template includes property filtering to avoid errors with non-existent properties.
   - The template uses a reliable note association pattern: create note first, then associate via batch API (more reliable than inline associations).
   
**About Section 4.5 (Bi-Directional Auto-Discovery - META ENRICHMENT):**
   - **BI-DIRECTIONAL BRANCHING**: Section 4.5 works for BOTH contacts AND companies, creating a fully interconnected database:
     * **Enriching a CONTACT** → Discovers company → Enriches/creates company → Discovers team members → Enriches them → Links everything
     * **Enriching a COMPANY** → Discovers team members → Enriches/creates them → Links to company
   
   - **META ENRICHMENT PRINCIPLE**: When research discovers new entities (companies, people), enrich them with ALL available data, just like the main record. This creates a comprehensive, interconnected database.
   
   - **Company Auto-Creation & Enrichment** (when enriching a CONTACT):
     * If contact has a `company` field, the script will:
     * Search for that company in HubSpot by name AND domain (robust duplicate prevention)
     * If found: Enrich existing company with any new data from research, then link contact
     * If NOT found: CREATE the company with ALL available details from research (domain, website, city, state, description, about_us, industry, etc.)
     * Then link the contact to the company
   
   - **Team Member Discovery & Full Enrichment** (works for BOTH contacts and companies): **CRITICAL** - Extract ALL team members/partners mentioned in your research note and add them to the `otherTeamMembers` array in section 4.5. Examples:
     * If note says "Other key people: Pat Matthews (Managing Partner), Cathy Dizon (Partner)" → add BOTH
     * If note mentions "Partners include..." → extract ALL mentioned
     * If note lists team members anywhere → extract ALL of them
     * **When enriching a COMPANY**: Extract all partners/team members mentioned in research
     * **When enriching a CONTACT**: Extract all other people at their company mentioned in research
   
   - **For each team member, include ALL information found in research** (META ENRICHMENT):
     * Name (firstname, lastname) - REQUIRED
     * Email - if found
     * Phone - if found
     * Job title - if mentioned
     * Company name - use `objectType === "companies" ? propertiesToUpdate.name : propertiesToUpdate.company`
     * City, State - if found
     * Website - if found
     * Social profiles (LinkedIn URL, Twitter handle) - if found
     * Investor type, helps_with, why_targeted, best_topic_to_connect_on, notes - if relevant
     * ANY other details from research
   
   - The script will (META ENRICHMENT):
     * Search for existing contacts by email (if found) or by name (firstname + lastname)
     * If found: Update existing contact with ALL new research data
     * If not found: Create new contact with ALL available research data
     * Automatically link them to the company (uses objectId when enriching company, companyIdForLinking when enriching contact)
     * If team member's company doesn't exist, create it with full enrichment
     * This ensures every discovered entity is fully enriched, not just created with minimal data
   
**About Section 5 (Additional Contacts - Optional/Legacy):**
   - **Section 4.5 is the primary method** for bi-directional branching and handles team member discovery for both contacts and companies.
   - **Section 5 is optional** and can be omitted in most cases. Only include if you have a very large number of team members that need to be added beyond what's in section 4.5.
   - **For enriching a contact**: Omit section 5 entirely. Use section 4.5 for team members.
   - **For enriching a company**: Section 4.5 should handle team member discovery. Only use section 5 if you have additional contacts not mentioned in the research note that need to be added.
   - **Note**: Section 4.5 provides full META ENRICHMENT with bi-directional branching. Section 5 uses the same upsert pattern but is primarily for bulk additions outside of research discoveries.

Target Profile URL: [PASTE THE HUBSPOT URL HERE, e.g., https://app.hubspot.com/contacts/45592037/contact/101]
